name: Ready for dev -> linked branch + in-progress

on:
  issues:
    types: [labeled]

permissions:
  contents: write
  issues: write

jobs:
  prepare-dev:
    if: ${{ github.event.label.name == 'ready-for-dev' }}
    runs-on: ubuntu-latest

    steps:
      - name: Create linked branch (GraphQL) and swap labels
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const issue = context.payload.issue;
            const issueNumber = issue.number;
            const issueTitle = issue.title || `issue-${issueNumber}`;
            const issueNodeId = issue.node_id; // GraphQL node ID

            // Slugify title for branch name
            const slug = issueTitle
              .toLowerCase()
              .replace(/[^a-z0-9]+/g, "-")
              .replace(/(^-|-$)/g, "")
              .slice(0, 50);

            const branchName = `issue-${issueNumber}-${slug || "work"}`;

            // Find default branch + its commit SHA (oid)
            const repoInfo = await github.rest.repos.get({ owner, repo });
            const baseBranch = repoInfo.data.default_branch;

            const baseRef = await github.rest.git.getRef({
              owner, repo,
              ref: `heads/${baseBranch}`,
            });

            const baseSha = baseRef.data.object.sha;

            // Remove 'needs-planning' label if present
            try {
              await github.rest.issues.removeLabel({
                owner, repo,
                issue_number: issueNumber,
                name: "needs-planning",
              });
            } catch (e) {}

            // If the branch already exists, we can't "link it" via GraphQL (only create+link).
            // We'll skip creating and leave a note in the logs.
            let branchExists = true;
            try {
              await github.rest.git.getRef({ owner, repo, ref: `heads/${branchName}` });
            } catch (e) {
              branchExists = false;
            }

            if (!branchExists) {
              // Create AND link the branch to the issue using GraphQL
              const mutation = `
                mutation CreateLinkedBranch($input: CreateLinkedBranchInput!) {
                  createLinkedBranch(input: $input) {
                    linkedBranch {
                      ref { name }
                    }
                    issue { number }
                  }
                }
              `;

              await github.graphql(mutation, {
                input: {
                  issueId: issueNodeId,
                  oid: baseSha,
                  name: branchName,
                },
              });
            } else {
              core.warning(
                `Branch '${branchName}' already exists. ` +
                `GitHub does not currently expose an API to link an existing branch to an issue; ` +
                `if the issue UI still shows "Create a branch", delete & recreate via this workflow or link it in the UI.`
              );
            }

            // Swap labels: ready-for-dev -> in-progress
            try {
              await github.rest.issues.removeLabel({
                owner, repo,
                issue_number: issueNumber,
                name: "ready-for-dev",
              });
            } catch (e) {}

            await github.rest.issues.addLabels({
              owner, repo,
              issue_number: issueNumber,
              labels: ["in-progress"],
            });